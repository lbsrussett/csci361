	.globl part_three
part_three:
	//72 101 108 108 111, 32, 87 111 114 108 100 == Hello World in ASCII
	// 01001000 01100101 01101100 01101100 01101111, 00100000, 01010111 01101111 01110010 01101100 01100100
	//Hello, ,World
	//11 chars long + 0 for end byte, 12*8 = 96

	//PUT 72, "H", IN REG X0 WHICH IS BASE OF ARRAY
	//ADD X2, XZR, XZR
	MOV X1, #72 //X1 = 72 + 0
	STUR X1,[X0,#0] //STORE "H" IN FIRST POSITION OF X0
	

	//PUT "e" IN ARRAY BY MULTIPLYING 1.1*100 TO GET 101
	//LEARNING GOAL: PRACTICE WITH FLOATING POINT OPERATIONS
	//FCVTZS NAME OF INT REGISTER, NAME OF SCALAR REGISTER
	ADD X2, XZR, XZR
	// PUT 10 IN X2
	MOV X2, #100
	//CONVERT X2 INTO A SCALAR REGISTER
	SCVTF S12, X2
	// PUT 11 IN X13
	MOV X13, #101
	// CONVERT X13 INTO SCALAR REGISTER
	SCVTF S13, X13
	// PUT 100 INTO X15
	MOV X15, #100
	// CONVERT X15 INTO SCALAR REGISTER
	SCVTF S15, X15
	// DIVIDE S13 BY S12 AND STORE IN S14
	FDIV S14, S13, S12
	// MULTIPLE S14 BY S15 AND STORE IN S1
	FMUL S1, S14, S15
	// CONVERT S1 BACK INTO AN INTEGER REGISTER
	FCVTZS X1, S1
	STUR X1,[X0,#8] // STORE 101 IN X3 POSITION 2

	//PUT "l' IN ARRAY BY LOOPING TO MULTIPLY BY ADDITION "36" THREE TIMES
	//LEARNING GOAL: TO GET SOME SIMPLE LOOP PRACTICE IN
	ADD X1, XZR, XZR // SET X1 = 0
	MOV X19, #1
	MOV X20, #3
	loop1:
		CMP X19, X20
		B.EQ ret //IF EQUAL, RETURN TO CALLING FUNCTION
		ADD X1, X1, #32
		ADD X19, X19, #1 // INCREMENT LOOP CONTROL VARIABLE
		B loop1
	ret:
	MOV X2, #44
	ADD X1, X1, X2
	STUR X1, [X0, #16]

	//PUT SECOND "l" IN ARRAY BY CONVERTING 108 TO NEGATIVE NUMBER AND STORE AS TWO'S COMPLIMENT, AND BACK.
	//LEARNING GOAL: LEARN HOW TO DO TWO'S COMPLIMENT CONVERSION IN ASSEMBLY
	ADD X3, XZR, XZR
	ADD X2, X3, #108
	MVN X4, X2 // STORES FLIPPED BITS OF 108 IN X4, SO 10010011
	ADD X4, X4, #1 // ADD 1 TO FINISH INITIAL TWO'S COMPLIMENT. X4 SHOULD NOW BE 10010100 = -108
	//CONVERT BACK
	MVN X4, X4
	ADD X4, X4, #1
	//STORE 108 IN ARRAY POSITION 3
	STUR X4,[X0, #24]

	//PUT "o" IN ARRAY BY USING FIBONACCI SEQUENCE 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89
	//LEARNING GOAL: TO LOOP EFFECTIVELY AND ADD VALUES BASED ON AN ITERATOR, PRACTICE ACCESSING ARRAY ELEMENTS
	MOV X17, #7
	MOV X18, #8
	MOV X19, #9
	ADD X20, XZR, XZR
	MOV X12, #0 // ZERO OUT X12
	ADD X12, X12, #1 // ADD 1 TO X12
	ADD X20, X20, X12
	ADD X13, X12, X12 // ADD X12 TWICE TO X13
	MOV X9, #2 // SET X9 TO 2 TO USE AS ITERATOR
	B fibloop // BRANCH TO FIBONACCI LOOP

	fibloop:
		ADD X9, X9, #1
		ADD X10, X13, X12 // ADD PREVIOUS 2 FIBONACCI ELEMENTS
		MOV X12, X13
		MOV X13, X10
		CMP X9, X17
		B.EQ sum
		CMP X9, X18
		B.EQ sum
		CMP X9, X19
		B.EQ sum
		B.NE fibloop

	sum:
		ADD X20, X20, X10
		CMP X20, #111
		B.EQ fibdone
		B.NE fibloop

	fibdone:
		STUR X20, [X0, #32]


	//ADD "space" TO ARRAY BY ADDING 32 TO THE ARRAY
	MOV X2, #32
	STUR X2, [X0, #40]

	//ADD "W" TO ARRAY USING LSL AND LSR
	//LEARNING GOAL: TO PRACTICE MULTIPLICATION AND DIVISION USING LOGICAL SHIFTS
	ADD X2, XZR, XZR // ZERO OUT X2
	ADD X4, X2, #348 // ADD 348 TO X5
	ADD X1, XZR, X4 // ADD X4 TO X1
	LSR X1, X1, #2 // USE LSR TO DIVIDE 348 BY 4
	LSL X1, X1, #1 // USE LSL TO MULTIPLY 87 BY 2
	STUR X1, [X0, #48] // ADD 174 TO THE HELLO WORLD ARRAY

	//ADD "o" TO ARRAY USING EOR TO CALCULATE BINARY VALUE 01101111
	//LEARNING GOAL: TO PROPERLY USE THE EOR OPERATION TO CREATE A DESIRED BINARY VALUE
	ADD X2, XZR, XZR // ZERO OUT X2
	MOV X10, #255 // ADD 1111 1111 TO X10
	MOV X11, #144 // ADD 1001 0000 TO X11
	EOR X2, X10, X11 // USE EOR TO CALCULATE 01101111 IN X2
	STUR X2, [X0, #56] // ADD 111 TO HELLO WORLD ARRAY

	//ADD "r" TO ARRAY USING A CONDITIONAL LOOP METHOD TO CORRECTLY CALCULATE THE ASCII CODE 114
	//LEARNING GOAL: TO PRACTICE LOOPS AND CONDITIONAL COMPARISONS TO CHECK CALCULATIONS
	ADD X2, XZR, XZR // ZERO OUT X2
	MOV X10, #4 // PUT 4 INTO X10
	MOV X11, #10 // PUT 10 INTO X11
	MOV X12, #100 // PUT 100 INTO X12
	MOV X13, #114 // PUT 114 INTO X13 AS DESIRED RESULT
	rloop:
		ADD X2, X2, X10 // ADD X10 TO SUM IN X2
		CMP X2, X13 // COMPARE SUM TO DESIRED RESULT
		B.EQ done // BRANCH IF EQUAL
		ADD X2, X2, X11 // ADD X11 TO SUM
		CMP X2, X13 // COMPARE SUM
		B.EQ done // BRANCH IF EQUAL
		ADD X2, X2, X12 // ADD X12 TO SUM
		CMP X2, X13 // COMPARE SUM
		B.EQ done // BRANCH IF EQUAL

	done:
		STUR X2, [X0, #64] // ADD 114 TO HELLO WORLD ARRAY

	//ADD "l" TO THE ARRAY USING THE EUCLIDEAN ALGORITHM TO FIND THE GCD
	//LEARNING GOAL: TO PRACTICE CONDITIONAL BRANCHING AND USE LOGICAL SHIFTS FOR CALCULATION
	ADD X2, XZR, XZR // ZERO OUT X2
	ADD X20, XZR, XZR // ZERO OUT X20
	MOV X10, #216 // PUT 216 INTO X10
	MOV X11, #162 // PUT 162 INTO X11
	CMP X10, X11 // COMPARE X10 AND X11 FOR EQUALITY
	B.EQ gcdexit // EXIT IF X10 AND X11 ARE EQUAL
	CMP X10, X11 // COMPARE X10 AND X11
	B.GT gcd1 // BRANCH TO GCD1 IF X10 IS GREATER
	B.LT gcd2 // BRANCH TO GDC2 IF X11 IS GREATER

	gcd1:
		SUB X10, X10, X11 // PUT DIFFERENCE OF X10 AND X11 INTO X10
		MOV X2, X10 // MOVE DIFFERENCE INTO X2 FOR ANSWER
		B gcdexit

	gcd2:
		SUB X11, X11, X10 // PUT DIFFERENCE OF X11 AND X10 INTO X11
		MOV X2, X11 // MOVE DIFFERENCE INTO X2 FOR ANSWER
		B gcdexit

	gcdexit:
		LSL X2, X2, #1 // LOGICAL SHIFT LEFT TO MUTIPLY ANSWER BY 2 TO CREATE 108
		STUR X2, [X0, #72] // ADD 108 TO HELLO WORLD ARRAY

	// ADD "d" TO THE ARRAY USING AN ITERATIVE LOOP
	//LEARNING GOAL: TO PRACTICE ITERATION AND BRANCH CONDITIONS
	ADD X2, XZR, XZR // ZERO OUT X2
	MOV X11, #2 // PUT 2 INTO X11 AS MULTIPLIER
	MOV X12, #6 // PUT 7 INTO X12 AS TERMINATION CONDITION
	MOV X20, #2 // PUT 2 INTO X20 AS MULTIPLICAND
	ADD X21, XZR, XZR // ZERO OUT X21 AS ITERATOR
	B dloop // LOOP

	dloop:
		CMP X12, X21 // COMPARE ITERATOR TO TERMINATION CONDITION
		B.EQ ddone // BRANCH IF CONDITION MET
		MUL X11, X11, X20 // SQUARE X11
		ADD X21, X21, #1 // INCREMENT ITERATOR
		B dloop // LOOP

	ddone:
		SUB X2, X11, #28 // SUBTRACT 28 FROM X20
		STUR X2, [X0, #80] // ADD 100 TO HELLO WORLD ARRAY

	//ADD NULL TERMINATOR TO END OF THE ARRAY
	MOV X2, #0;
	STUR X2, [X0, #88]







//85 LINES WITH 16 UNIQUE COMMANDS


	br	X30

	//CHAR OPERATIONS: PG 113
	//FLOATING POINT OPERATIONS: PG221
