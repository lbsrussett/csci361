	.globl part_three
part_three:
	//72 101 108 108 111, 32, 87 111 114 108 100 == Hello World in ASCII
	// 01001000 01100101 01101100 01101100 01101111, 00100000, 01010111 01101111 01110010 01101100 01100100
	//Hello, ,World
	//11 chars long + 0 for end byte, 12*8 = 96

	//PUT 72, "H", IN REG X3 WHICH IS BASE OF ARRAY
	ADD X2, XZR, XZR
	LDUR X1, [X2, #72]//X1 = 72 + 0
	//ADD X1, XZR, #72
	STURB W3,[X1,#0] //STORE "H" IN FIRST POSITION OF X3
	// FROM THE BOOK: "Store byte "STURB" takes a byte from the rightmost 8 bits of a register and writes it to memory.
	//NOTE THAT WE DO NOT NEED TO MULTIPLY THE OFFSET BY 8 AS THIS IS AN ARRAY OF BYTES

	//PUT "e" IN ARRAY BY MULTIPLYING 1.1*100 TO GET 101
	//LEARNING GOAL: PRACTICE WITH FLOATING POINT OPERATIONS
	//FCVTZS NAME OF INT REGISTER, NAME OF SCALAR REGISTER
	ADD X2, XZR, XZR
	// PUT 10 IN X2
	MOV X2, #10
	//CONVERT X2 INTO A SCALAR REGISTER
	SCVTF S12, X2
	// PUT 11 IN X13
	MOV X13, #11
	// CONVERT X13 INTO SCALAR REGISTER
	SCVTF S13, X13
	// PUT 100 INTO X15
	MOV X15, #100
	// CONVERT X15 INTO SCALAR REGISTER
	SCVTF S15, X15
	// DIVIDE S13 BY S12 AND STORE IN S14
	FDIV S14, S13, S12
	// MULTIPLE S14 BY S15 AND STORE IN S1
	FMUL S1, S14, S15
	// CONVERT S1 BACK INTO AN INTEGER REGISTER
	FCVTZS X1, S1
	STURB W3,[X1,#1] // STORE 101 IN X3 POSITION 2

	//PUT "l' IN ARRAY BY LOOPING TO MULTIPLY BY ADDITION "36" THREE TIMES
	//LEARNING GOAL: TO GET SOME SIMPLE LOOP PRACTICE IN
	ADD X1, XZR, XZR // SET X1 = 0
	MOV X19, #1
	MOV X20, #3
	loop1:
		CMP X19, X20
		//B.EQ LR //IF EQUAL, RETURN TO CALLING FUNCTION
		ADD X1, X1, #32
		ADD X19, X19, #1 // INCREMENT LOOP CONTROL VARIABLE
		B loop1
	STURB W3, [X1, #2]

	//PUT SECOND "l" IN ARRAY BY CONVERTING 108 TO NEGATIVE NUMBER AND STORE AS TWO'S COMPLIMENT, AND BACK.
	//LEARNING GOAL: LERN HOW TO DO TWO'S COMPLIMENT CONVERSION IN ASSEMBLY
	ADD X1, XZR, XZR
	ADD X2, X1, #108
	MVN X4, X2 // STORES FLIPPED BITS OF 108 IN X4, SO 10010011
	ADD X4, X4, #1 // ADD 1 TO FINISH INITIAL TWO'S COMPLIMENT. X4 SHOULD NOW BE 10010100 = -108
	//CONVERT BACK
	MVN X4, X4
	ADD X4, X4, #1
	//STORE 108 IN ARRAY POSITION 3
	STURB W3,[X4, #3]

	//PUT "o" IN ARRAY BY USING FIBONACCI SEQUENCE
	ADD X2, XZR, XZR // ZERO OUT X2
	LDUR X2, [X2, #0] // LOAD 0 INTO FIRST ARRAY ELEMENT
	MOV X15, #1 // MOVE 1 INTO X15
	LDUR X2, [X15, #8] // LOAD 1 INTO 2ND ARRAY ELEMENT
	ADD X16, X15, X15 // ADD 2 TO X16
	LDUR X2, [X16, #16] // LOAD 2 INTO 3RD ARRAY ELEMENT
	ADD X9, XZR, XZR // ZERO OUT X9 TO USE AS ITERATOR
	ADD X10, XZR, XZR  // ZERO OUT X10
	ADD X10, X10, #3 // ADD 3 TO X10 TO USE AS ARRAY INDEX
	ADD X12, XZR, XZR // ZERO OUT X12
	MOV X12, #12 // MOVE 12 INTO X12 AS TERMINATION CONDITION
	B fibloop // BRANCH TO FIBONACCI LOOP

	fibloop:
		ADD X9, X9, #1 // INCREMENT X9 BY 1
		ADD X16, X16, X15 // ADD PREVIOUS 2 FIBONACCI ELEMENTS TO X16
		MOV X13, #8 // MOVE 8 INTO X13
		MUL X11, X10, X13 // MULTIPLY ARRAY INDEX BY 8 FOR OFFSET AND PUT IN X11
		LDUR X2, [X2, X11] // LOAD ELEMENT INTO ARRAY AT OFFSET IN X11
		ADD X10, X10, #1 // INCREMENT ARRAY INDES
		CMP X9, X12 // COMPARE ITERATOR TO TERMINATION CONDITION
		B.NE fibloop // LOOP IF TERMINATION CONDITION ISN'T REACHED

	ADD X17, XZR, XZR // ZERO OUT X17
	LDUR X18, [X2, #16] // ADD 2ND FIBONACCI ELEMENT TO X18
	ADD X17, X17, X18 // SUM X17 AND X18
	LDUR X19, [X2, #40] // ADD 5TH FIBONACCI ELEMENT TO X19
	ADD X17, X17, X19 // SUM X17 AND X19
	LDUR X20, [X2, #64] // ADD 8TH FIBONACCI ELEMENT TO X20
	ADD X17, X17, X20 // SUM X17 AND X20
	LDUR X21, [X2, #88] // ADD 11TH FIBONACCI ELEMENT TO X21
	ADD X17, X17, X22 // SUM X17 AND X21
	STURB W3, [X17, #4] // ADD 111 TO HELLO WORLD ARRAY


	//ADD "W" TO ARRAY USING LSL AND LSR
	//LEARNING GOAL: TO PRACTICE MULTIPLICATION DIVISION USING LOGICAL SHIFTS
	ADD X2, XZR, XZR // ZERO OUT X2
	ADD X4, X2, #348 // ADD 348 TO X5
	ADD X1, XZR, X4 // ADD X4 TO X1
	LSR X1, X1, #4 // USE LSR TO DIVIDE 348 BY 4
	LSL X1, X1, #2 // USE LSL TO MULTIPLY 87 BY 2
	STURB W3, [X1, #5] // ADD 174 TO THE HELLO WORLD ARRAY

	//ADD "o" TO ARRAY USING EOR TO CALCULATE BINARY VALUE 01101111
	ADD X2, XZR, XZR // ZERO OUT X2
	MOV X10, #255 // ADD 1111 1111 TO X10
	MOV X11, #144 // ADD 1001 0000 TO X11
	EOR X2, X10, X11 // USE EOR TO CALCULATE 01101111 IN X2
	STURB W3, [X2, #6] // ADD 111 TO HELLO WORLD ARRAY

	//ADD "r" TO ARRAY USING A CONDITIONAL LOOP METHOD TO CORRECTLY CALCULATE THE ASCII CODE 114
	ADD X2, XZR, XZR // ZERO OUT X2
	MOV X10, #4 // PUT 4 INTO X10
	MOV X11, #10 // PUT 10 INTO X11
	MOV X12, #100 // PUT 100 INTO X12
	MOV X13, #114 // PUT 114 INTO X13 AS DESIRED RESULT
	rloop:
		ADD X2, X2, X10 // ADD X10 TO SUM IN X2
		CMP X2, X13 // COMPARE SUM TO DESIRED RESULT
		B.EQ done // BRANCH IF EQUAL
		ADD X2, X2, X11 // ADD X11 TO SUM
		CMP X2, X13 // COMPARE SUM
		B.EQ done // BRANCH IF EQUAL
		ADD X2, X2, X12 // ADD X12 TO SUM
		CMP X2, X13 // COMPARE SUM
		B.EQ done // BRANCH IF EQUAL

	done:
		STURB W3, [X2, #7] // ADD 114 TO HELLO WORLD ARRAY

	//ADD "l" TO THE ARRAY USING THE EUCLIDEAN ALGORITHM TO FIND THE GCD
	ADD X2, XZR, XZR
	ADD X20, XZR, XZR
	MOV X10, #216
	MOV X11, #162
	SUB X20, X10, X11
	CBZ gcdexit
	CMP X10, X11
	B.GT gcd1
	B.LT gcd2

	gcd1:
		SUB X10, X10, X11
		MOV X2, X10
		B gcdexit

	gcd2:
		SUB X11, X11, X10
		MOV X2, X11
		B gcdexit

	gcdexit:
		LSL X2, X2, #1
		STURB W3, [X2, #8]

	// ADD "d" TO THE ARRAY USING AN ITERATIVE LOOP
	ADD X2, XZR, XZR // ZERO OUT X2
	MOV X11, #2 // PUT 2 INTO X11 AS MULTIPLIER
	MOV X12, #7 // PUT 7 INTO X12 AS TERMINATION CONDITION
	MOV X20, #2 // PUT 2 INTO X20 AS MULTIPLICAND
	ADD X21, XZR, XZR // ZERO OUT X21 AS ITERATOR
	B dloop // LOOP

	dloop:
		CMP X12, X21 // COMPARE ITERATOR TO TERMINATION CONDITION
		B.EQ ddone // BRANCH IF CONDITION MET
		MUL X20, X20, X11 // MULTIPLY X20 BY X11
		ADD X21, X21, #1 // INCREMENT ITERATOR
		B dloop // LOOP

	ddone:
		SUB X2, X20, #28 // SUBTRACT 28 FROM X20
		STURB W3, [X2, #9] // ADD 100 TO HELLO WORLD ARRAY







//85 LINES WITH 16 UNIQUE COMMANDS


	br	X30

	//CHAR OPERATIONS: PG 113
	//FLOATING POINT OPERATIONS: PG221
