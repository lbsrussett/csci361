	.globl part_three
part_three:
	//72 101 108 108 111, 32, 87 111 114 108 100 == Hello World in ASCII
	// 01001000 01100101 01101100 01101100 01101111, 00100000, 01010111 01101111 01110010 01101100 01100100
	//Hello, ,World
	//11 chars long + 0 for end byte, 12*8 = 96

	//PUT 72, "H", IN REG X3 WHICH IS BASE OF ARRAY
	ADD X2, XZR, XZR
	LDUR X1, [X2, #72]//X1 = 72 + 0
	//ADD X1, XZR, #72
	STURB W3,[X1,#0] //STORE "H" IN FIRST POSITION OF X3
	// FROM THE BOOK: "Store byte "STURB" takes a byte from the rightmost 8 bits of a register and writes it to memory.
	//NOTE THAT WE DO NOT NEED TO MULTIPLY THE OFFSET BY 8 AS THIS IS AN ARRAY OF BYTES

	//PUT "e" IN ARRAY BY MULTIPLYING 1.1*100 TO GET 101
	//LEARNING GOAL: PRACTICE WITH FLOATING POINT OPERATIONS
	//FCVTZS NAME OF INT REGISTER, NAME OF SCALAR REGISTER
	ADD X2, XZR, XZR
	// PUT 10 IN X2
	MOV X2, #10
	//CONVERT X2 INTO A SCALAR REGISTER
	SCVTF S12, X2
	// PUT 11 IN X13
	MOV X13, #11
	// CONVERT X13 INTO SCALAR REGISTER
	SCVTF S13, X13
	// PUT 100 INTO X15
	MOV X15, #100
	// CONVERT X15 INTO SCALAR REGISTER
	SCVTF S15, X15
	// DIVIDE S13 BY S12 AND STORE IN S14
	FDIV S14, S13, S12
	// MULTIPLE S14 BY S15 AND STORE IN S1
	FMUL S1, S14, S15
	// CONVERT S1 BACK INTO AN INTEGER REGISTER
	FCVTZS X1, S1
	STURB W3,[X1,#1] // STORE 101 IN X3 POSITION 2

	//PUT "l' IN ARRAY BY LOOPING TO MULTIPLY BY ADDITION "36" THREE TIMES
	//LEARNING GOAL: TO GET SOME SIMPLE LOOP PRACTICE IN
	ADD X1, XZR, XZR // SET X1 = 0
	MOV X19, #1
	MOV X20, #3
	loop1:
		CMP X19, X20
		//B.EQ LR //IF EQUAL, RETURN TO CALLING FUNCTION
		ADD X1, X1, #32
		ADD X19, X19, #1 // INCREMENT LOOP CONTROL VARIABLE
		B loop1
	STURB W3, [X1, #2]

	//PUT SECOND "l" IN ARRAY BY CONVERTING 108 TO NEGATIVE NUMBER AND STORE AS TWO'S COMPLIMENT, AND BACK.
	//LEARNING GOAL: LERN HOW TO DO TWO'S COMPLIMENT CONVERSION IN ASSEMBLY
	ADD X1, XZR, XZR
	ADD X2, X1, #108
	MVN X4, X2 // STORES FLIPPED BITS OF 108 IN X4, SO 10010011
	ADD X4, X4, #1 // ADD 1 TO FINISH INITIAL TWO'S COMPLIMENT. X4 SHOULD NOW BE 10010100 = -108
	//CONVERT BACK
	MVN X4, X4
	ADD X4, X4, #1
	//STORE 108 IN ARRAY POSITION 3
	STURB W3,[X4, #3]

	//PUT "o" IN ARRAY BY USING FIBONACCI SEQUENCE
	ADD X2, XZR, XZR
	LDUR X2, [X2, #0]
	MOV X15, #1
	LDUR X2, [X15, #8]
	ADD X16, X15, X15
	LDUR X2, [X16, #16]
	ADD X9, XZR, XZR
	ADD X10, XZR, XZR
	ADD X10, X10, #3
	ADD X12, XZR, XZR
	MOV X12, #12
	B fibloop

	fibloop:
		ADD X9, X9, #1
		ADD X16, X16, X15
		MOV X13, #8
		MUL X11, X10, X13
		LDUR X2, [X2, X11]
		ADD X10, X10, #1
		CMP X9, X12
		B.NE fibloop

	ADD X17, XZR, XZR
	LDUR X18, [X2, #16]
	ADD X17, X17, X18
	LDUR X19, [X2, #40]
	ADD X17, X17, X19
	LDUR X20, [X2, #64]
	ADD X17, X17, X20
	LDUR X21, [X2, #88]
	ADD X17, X17, X22
	STURB W3, [X17, #4]


	//ADD "W" TO ARRAY USING LSL AND LSR
	//LEARNING GOAL: TO PRACTICE MULTIPLICATION DIVISION USING LOGICAL SHIFTS
	ADD X2, XZR, XZR // ZERO OUT X2
	ADD X4, X2, #348 // ADD 348 TO X5
	ADD X1, XZR, X4
	LSR X1, X1, #4
	LSL X1, X1, #2
	STURB W3, [X1, #5]

	//ADD "o" TO ARRAY USING EOR TO CALCULATE BINARY VALUE  01101111
	ADD X2, XZR, XZR
	MOV X10, #255
	MOV X11, #144
	EOR X2, X10, X11
	STURB W3, [X2, #6]

	//ADD "r" TO ARRAY USING A CONDITIONAL LOOP METHOD TO CORRECTLY CALCULATE THE ASCII CODE 114
	ADD X2, XZR, XZR
	MOV X10, #4
	MOV X11, #10
	MOV X12, #100
	MOV X13, #114
	rloop:
		ADD X2, X2, X10
		CMP X2, X13
		B.EQ done
		ADD X2, X2, X11
		CMP X2, X13
		B.EQ done
		ADD X2, X2, X12
		CMP X2, X13
		B.EQ done

	done:
		STURB W3, [X2, #7]

	//OTHER IDEAS:
	//USE LSL OR LSR TO MULTIPLY VALUES
	//USE LOGICAL OPERATIONS LIKE NOR OR EOR TO MODIFY VALUES, SUCH AS TAKE TWO VALUES 1011010, 0010101 AND USE LOGICAL OPERATIONS TILL IT EQUALS ONE OF OUR NEEDED VALUES. Pg. 91
	//CREATE A NUMBER SUCH AS 01100100, WHICH EQUALS D, BUT ADD SOME ONES AFTER IT, SO IT BECOMES 01100100111. THEN LSR TO REMOVE THE EXTRA ONES TO REVEAL THE TRUE VALUE
	//USE HAMMING CODE TO FIX AN INCORRECT PARITY BIT (LIKELY HARD TO DO)


//85 LINES WITH 16 UNIQUE COMMANDS


	br	X30

	//CHAR OPERATIONS: PG 113
	//FLOATING POINT OPERATIONS: PG221
