	.globl part_three
part_three:
	//72 101 108 108 111, 32, 87 111 114 108 100 == Hello World in ASCII
	// 01001000 01100101 01101100 01101100 01101111, 00100000, 01010111 01101111 01110010 01101100 01100100
	//Hello, ,World
	//11 chars long + 0 for end byte, 12*8 = 96

	//PUT 72, "H", IN REG X3 WHICH IS BASE OF ARRAY
	ADD X1, #72, ZYR //X1 = 72 + 0
	STURB X3,[X1,#0] //STORE "H" IN FIRST POSITION OF X3
	// FROM THE BOOK: "Store byte "STURB" takes a byte from the rightmost 8 bits of a register and writes it to memory.
	//NOTE THAT WE DO NOT NEED TO MULTIPLY THE OFFSET BY 8 AS THIS IS AN ARRAY OF BYTES

	//PUT "e" IN ARRAY BY MULTIPLYING 1.1*100 TO GET 101
	//LEARNING GOAL: PRACTICE WITH FLOATING POINT OPERATIONS
	FMULS X1, #1.1, #100 //MULTIPLY 1.1*100 AND STORE IN X1
	STURB X3,[X1,#1] // STORE 101 IN X3 POSITION 2

	//PUT "l' IN ARRAY BY LOOPING TO MULTIPLY BY ADDITION "36" THREE TIMES
	//LEARNING GOAL: TO GET SOME SIMPLE LOOP PRACTICE IN
	ADD X1, ZYR, ZYR // SET X1 = 0
	MOV X19, #1
	MOV X20, #3
	loop1:
		CMP X19, X20
		B.EQ LR //IF EQUAL, RETURN TO CALLING FUNCTION
		ADD X1, X1, #32
		ADD X19, X19, #1 // INCREMENT LOOP CONTROL VARIABLE
		B loop1

	//PUT SECOND "l" IN ARRAY BY CONVERTING 108 TO NEGATIVE NUMBER AND STORE AS TWO'S COMPLIMENT, AND BACK.
	//LEARNING GOAL: LERN HOW TO DO TWO'S COMPLIMENT CONVERSION IN ASSEMBLY
	MVN X4, #108 // STORES FLIPPED BITS OF 108 IN X4, SO 10010011
	ADD X4, X4, #1 // ADD 1 TO FINISH INITIAL TWO'S COMPLIMENT. X4 SHOULD NOW BE 10010100 = -108
	//CONVERT BACK
	SUB X4, X4, #1
	MVN X4, X4
	//STORE 108 IN ARRAY POSITION 3
	STURB X3,[X4,#2]

	//PUT "o" IN ARRAY BY


//17 LINES WITH 9 UNIQUE COMMANDS

	//OTHER IDEAS:
	//USE LSL OR LSR TO MULTIPLY VALUES
	//USE LOGICAL OPERATIONS LIKE NOR OR EOR TO MODIFY VALUES, SUCH AS TAKE TWO VALUES 1011010, 0010101 AND USE LOGICAL OPERATIONS TILL IT EQUALS ONE OF OUR NEEDED VALUES. Pg. 91
	//CREATE A NUMBER SUCH AS 01100100, WHICH EQUALS D, BUT ADD SOME ONES AFTER IT, SO IT BECOMES 01100100111. THEN LSR TO REMOVE THE EXTRA ONES TO REVEAL THE TRUE VALUE
	//USE HAMMING CODE TO FIX AN INCORRECT PARITY BIT (LIKELY HARD TO DO)




	br	X30

	//CHAR OPERATIONS: PG 113
	//FLOATING POINT OPERATIONS: PG221
